/* Програма за Arduino UNO за измерване на електромагнитно поле и визуализирането на данните в реално време.
 * Изготвено от Анастасия Генова през 9.2018.
*/

/* Библиотеки за управление на дисплей HX8357 */
#include <Adafruit_GFX.h>     // Библиотека, съдържаща функции за изобразяване на графики върху Adafruit дисплеи
#include <SPI.h>              // Библиотека, нужна за управление на екрана в режим SPI
#include "Adafruit_HX8357.h"  // Библиотека, съдържаща базов код за управление на дисплей HX8357
#include "TouchScreen.h"      // Библиотека, съдържаща функции за управление на резистивния сензорен екран

/* Настройване на пинове за управление на дисплей HX8357 */
#define YP A2       // Задължително трябва да бъде аналогов пин, обозначете с "An".
#define XM A3       // Задължително трябва да бъде аналогов пин, обозначете с "An".
#define YM 7        // Може да бъде и digital (дигитален) пин
#define XP 8        // Може да бъде и digital (дигитален) пин
#define TFT_RST -1  // не използваме reset пин
#define TFT_DC 9    // дигитален пин 9
#define TFT_CS 10   // дигитален пин 10

/* Данни за калибриране на резистивния сензорен екран */
#define TS_MINX 110
#define TS_MINY 80
#define TS_MAXX 900
#define TS_MAXY 940

/* Данни за натиска, който бива упражняван върху резистивния екран */
#define MINPRESSURE 10
#define MAXPRESSURE 1000

/* Обекти за управление на HX8357*/
Adafruit_HX8357 tft = Adafruit_HX8357(TFT_CS, TFT_DC); // Обект, използван за основно управление на дисплея. 
// За по-добра прецизност трябва да знаем съпротивлението между X+ и X-. Може да се използва мултиметър, за да се засече. За случая използваме 300 ома. 
TouchScreen ts = TouchScreen(XP, YP, XM, YM, 300);     // Обект, използван при управление на резистивния сензорен екран на дисплея. 

/* Цветове за визуализиране на графики */
#define BLUE      0x001F    // Синьо
#define GREEN     0x07E0    // Зелено
#define CYAN      0x07FF    // Циан
#define RED       0xF800    // Червено
#define YELLOW    0xFFE0    // Жълто
#define WHITE     0xFFFF    // Бяло
#define BLACK     0x0000    // Черно

/* Променливи за изобразяване на графики и визуализиране на данни */
bool firstDrawGraph = true; // Променлива, сигнализираща дали графиката трябва да бъде изобразена за пръв път, включително всички периферни текстове и обозначения на координати
double ox , oy ;            // Начални координати за графиката
double x, y;                // Нови координати за графиката
int xHead = 10;             // Променлива за управление на координатата Х (Време) - крайна точка 10
int xTail = 0;              // Променлива за управление на координатата Х (Време) - начална точка 0 

/* Променливи за изписване на изминалото време от началото на отчитане на данни */
int dhrs = 0;               // Променлива, която съхранява десетиците на изминалите часове
int uhrs = 0;               // Променлива, която съхранява единиците на изминалите часове
int dmin = 0;               // Променлива, която съхранява десетиците на изминалите минути
int umin = 0;               // Променлива, която съхранява единиците на изминалите минути
int dsec = 0;               // Променлива, която съхранява десетиците на изминалите секунди
double usec = 0;            // Променлива, която съхранява единиците на изминалите секунди
int intCounter = 0;         // Променлива, която служи за отброяване на 10 секунди за целите на отброяване на времето от началото на отчитането на данни

/* Променливи за обозначаване на различни екрани от потребителския интерфейс */
int currentScreen = 0;      // Променлива, която указва текущият екран. Към текущата версия на изходния код екраните са 0 = Начален екран и 1 = Екран за визуализация на данни
bool screen0 = false;       // Променлива, която указва, че елементи на началният екран, които трябва да бъдат изобразени само веднъж, вече са били изобразени
bool screen1 = false;       // Променлива, която указва, че елементи на екранът за визуализация на данните и рисуване на графики, които трябва да бъдат изобразени само веднъж, вече са били изобразени

/* Променливи за отчитане на стойности за електромагнитно поле */
#define NUMREADINGS 15      // Променлива за чувствителност на отчитането. 
                            // Увеличете за завишена чувствителност. 
int senseLimit = 15;        // Променлива за чувствителност при закръгляне на отчитането. 
                            // Увеличете за намалена чувствителност (до 1023 максимум).
int probePin = 1;           // Аналогов пин 1
int val = 0;                // Стойността, която отчитаме от аналогов пин 1

/* Променливи за закръгляне на отчитането */
int readings[NUMREADINGS];  // Брой получени данни от аналоговия пин съхранени в масив
int index = 0;              // Индексът на текущото отчитане
int total = 0;              // Текущият сбор от всички NUMREADINGS отчитания
int average = 0;            // Финална изчислена средна стойност на всички отчитания
int updateTime = 100;       // Колко често (в милисекунди) се отчита стойност от аналоговия пин

void setup() {
  Serial.begin(9600);       // Инициализираме връзка Serial

  for (int i = 0; i < NUMREADINGS; i++)
    readings[i] = 0;        // Инициализираме всички стойности за отчитанията с 0

  tft.begin(HX8357D);       // Инизиализираме дисплей HX8357D
  tft.fillScreen(BLACK);    // Започваме с напълно черен екран
  tft.setRotation(3);       // Избраната ориентация на екрана за нашия проект. 
}

/* Основна функция на настоящия Arduino изходен код, която се изпълнява многократно до преустановяване на устройството
 * В момента фунцията се изпълнява приблизително 10 пъти в секунда, обозначено от командата "delay(100);", която кара фунцията да
 * чака 100 милисекунди или 0.1 секунда преди да започне да се изпълнява отново. Има забавяне, което е равно на времето, което отнема 
 * да се изпълни кода в самата функция, но на този етап то е пренебрежимо. 
 */
void loop() {  
  if(currentScreen == 0){                 // Начален екран
    /* Изобразяване на начален екран */
    /* Изобразяване на елементите, които трябва да се визуализират само веднъж */
    if(!screen0){                         // В случай, че "еднократните" елементи все още не са били изобразени...
      tft.setCursor(80, 120);             // Поставяме контекста на рисуване ("указател, курсор") на 80 пиксела по Х координата и на 120 пиксела по Y координата 
      tft.setTextColor(RED);              // Избираме цвета, с който ще изобразяваме желания текст
      tft.setTextSize(2);                 // Избираме размера на текста
      tft.print("VERSION 1.0.0");         // Изобразяваме указания текст на координатите и с опциите указани по-горе
      tft.setCursor(80, 140);
      tft.setTextColor(BLUE);
      tft.setTextSize(2);
      tft.print("LAST UPDATE: 30/9/2018");
      tft.setCursor(80, 160);
      tft.setTextColor(WHITE);
      tft.setTextSize(6);
      tft.print("EMF_GHOST");
  
      tft.fillRoundRect(160, 220, 150, 40, 15, WHITE);    // Изобразяваме запълнен в бяло правоъгълник с 15 градуса заглаждане на върховете, 
                                                          // с размери 150px дължина и 40px ширина, на координати 160 по Х и 220 по Y. 
      tft.drawRoundRect(160, 220, 150, 40, 15, YELLOW);   // Изобразяваме незапълнен правоъгълник с жълт ръб със същите настройки като горния правоъгълник, 
                                                          // за да застане като негова рамка (border). 
      tft.setCursor(190, 230);
      tft.setTextColor(BLACK);
      tft.setTextSize(3);
      tft.print("START");
  
      screen0 = true;                     // Елементите, които трябва да бъдат изобразени еднократно вече са били изобразени и сигнализираме, че няма нужда от повторна визуализация
    }
    
  /* Код за отчитане на натиск върху резистивния сензорен екран */
  TSPoint p = ts.getPoint();                        // Всеки път, когато този блок код бъде изпълнен, взимаме нова точка на натиск 
 
  if (p.z < MINPRESSURE || p.z > MAXPRESSURE) {     // Имаме минимален и максимален натиск, който считаме за "валиден" или обозначаващ реално натискане
     return;                                        // В случай, че отчетеният натиск не е в рамките на "валиден" натиск, спираме изпълнението на командите и започваме отначало
  }

  if(p.y >= 410 && p.y <= 630 && p.x >= 650 && p.x <= 800){     // Обозначаваме, че се интересуваме от натиск в тези рамки (по X и Y). В нашия случай, това е бутон "START" на главния екран
    tft.fillRoundRect(160, 220, 150, 40, 15, YELLOW);           // Искаме да известим потребителя щом като отчетем натиск върху бутона и затова сменяме цвета на фона на ЖЪЛТ
    tft.drawRoundRect(160, 220, 150, 40, 15, WHITE);            // и сменяме цвета на рамката на БЯЛ
    tft.setCursor(190, 230);                                    // Изписваме отново текста старт, тъй като по-горните команди на практика са го "изтрили" 
    tft.setTextColor(BLACK);                                    // Заслужава си да се отбележи, че тези команди са с цел да подобрят потребителския интерфейс и нямат голямо практическо значение
    tft.setTextSize(3);
    tft.print("START");

    // След като потребителят натисне бутона START искаме да сменим екрана от началния екран на този, визуализиращ данните в реално време
    tft.fillScreen(BLACK);                                      // Оцветяваме екрана в черно, за да го "изчистим" за следващия екран. Тази команда е валидна, защото фонът на всички екрани е черен
    currentScreen = 1;                                          // Сменяме контекста на екрана - следващия път, когато програмата мине през цикъла loop(); няма да нарисува началния екран, а екран 1
  }

} else if(currentScreen = 1){             // Екран за визуализиране на данните за електромагнитно поле, подадени от антената
    /* Изобразяване на екран за визуализиране на данни */
    /* Еднократно и първоначално изобразяване на панели за текуща средна стойност и изминало време */
    if(!screen1){                         // В случай, че "еднократните" елементи все още не са били визуализирани...
      // Изобразяваме полето за часовника и първоначално време от 00:00:00
      tft.fillRoundRect(330, 0, 110, 18, 5, WHITE);
      tft.setCursor(335, 2);
      tft.setTextColor(BLACK);
      tft.setTextSize(2);
      tft.print(dhrs);  
      tft.print(uhrs);  
      tft.print(":");  
      tft.print(dmin);  
      tft.print(umin);  
      tft.print(":");  
      tft.print(dsec);  
      tft.print(round(usec));             // usec е променлива от тип double, тъй като към нея добавяме 100 милисекунди (0.1 секунда), което е периодът на отчитане на нови данни
                                          // а също и периодът, с който измерваме честотата на обновяване на часовника (на всеки 1000 милисекунди или 1 секунда). 
                                          // Изобразяваме я с функцията round() ("закръгляне"), за да визуализираме само секундите (1000 милисекунди = 1 секунда) без точност след десетичната запетая. 
                                          // Другите променливи няма нужда да са от тип double, тъй като те винаги ще са цели числа.
      
      // Изобразяваме поясняващ текст под полето за изминало време
      tft.setCursor(330, 20);                           
      tft.setTextColor(YELLOW);
      tft.setTextSize(1);
      tft.print("time since launch");

      // Изобразяваме полето и първоначална нулева стойност за текущата средна стойност, отчетена от антената
      tft.fillRoundRect(230, 0, 90, 18, 5, WHITE);
      tft.setCursor(235, 2);
      tft.setTextColor(BLACK);
      tft.setTextSize(2);
      tft.print(average);  

      // Изобразяваме поясняващ текст под полето за текущата средна стойност, отчетена от антената
      tft.setCursor(230, 20);
      tft.setTextColor(YELLOW);
      tft.setTextSize(1);
      tft.print("Current Average");      

      screen1 = true;                     // Елементите, които трябва да бъдат изобразени еднократно вече са били изобразени и сигнализираме, че няма нужда от повторна визуализация
    }

    /* Начало на отчитането и визуализирането на данни от антената */
    val = analogRead(probePin);                 // Отчитаме стойност от аналоговия пин
    if (val >= 1) {                             // Ако стойността не е 0, продължаваме напред
      // Serial.print("\nRaw Val: ");           // Изпращаме необработената "Сурова" Raw стойност по Serial
      // Serial.print(val);
      val = constrain(val, 1, senseLimit);      // Ако отчетем стойност по-висока от senseLimit, то я превръщаме ("ограничаваме") в senseLimit (constrain)
      val = map(val, 1, senseLimit, 1, 1023);   // Превръщаме "ограничената" стойност в съответсващата й стойност между 1 и 1023.
      total -= readings[index];                 // Изваждаме миналата отчетена стойност от общия сбор
      readings[index] = val;                    // Слагаме отчетената стойност на текущия индекс в масива от отчетени стойности
      total += readings[index];                 // Добавяме новата отчетена стойност към общия сбор
      index = (index + 1);                      // Минаваме към следващия индекс от масива
      if (index >= NUMREADINGS)                 // Ако сме стигнали до края на масива се връщаме в началото му (0)
        index = 0;                           
      average = total / NUMREADINGS;            // Изчисляваме средната стойност и съхраняваме в променлива average
  
      Serial.print(average);                    // Изпращаме средната стойност по Serial
      Serial.print("\n");

      /* Код за изобразяване на изминали секунди от началото на отчитането на данни */
      if(intCounter == 9){                      // Часовникът отброява всяка секунда. 
                                                // intCounter служи за обозначаване на 10тото преминаване през кода, който завършва с команда "delay(100);", която
                                                // кара програмата да изчака 100 милисекунди (0.1 секунди) преди да отчете нова стойност (да започне отначало да изпълнява
                                                // този блок от изходен код. На всяко преминаване, intCounter се увеличава с 1, докато не достигне 9, след което се нулира. 

        // Всяка секунда изобразяваме ново бяло поле, за да "изчистим" времето, отброено преди това.
        tft.fillRoundRect(330, 0, 110, 18, 5, WHITE);

        // Проверки за обновяване на часа. 
        if(dsec == 5 && usec > 9){
          usec = 0;
          dsec = 0;
          umin += 1;
        } else if(usec > 9){
          usec = 0;
          dsec += 1;
        }
        
        if(dmin == 5 && umin > 9){
          umin = 0;
          dmin = 0;
          uhrs += 1;
        } else if(umin > 9){
          umin = 0;
          dmin += 1;
        }
  
        if(uhrs > 9){
          uhrs = 0; 
          dhrs += 1; 
        }
        
        // Часовникът поддържа време до 99:59:59 (99 часа, 59 минути и 59 секунди), след което се нулира. 
        if(dhrs == 9 && uhrs == 9 && dmin == 5 && umin == 9 && dsec == 5 && (int)usec == 9){        // Трябва да разгледаме double usec като int (цяло число), за да го сравним с цялото число 9. 
          dhrs = 0;
          uhrs = 0;
          dmin = 0;
          umin = 0;
          dsec = 0;
          usec = 0;
        }

        // Изобразяване на новото време
        tft.setCursor(335, 2);
        tft.setTextColor(BLACK);
        tft.setTextSize(2);
        tft.print(dhrs);  
        tft.print(uhrs);  
        tft.print(":");  
        tft.print(dmin);  
        tft.print(umin);  
        tft.print(":");  
        tft.print(dsec);  
        tft.print(round(usec));                 // Както и в кода за еднократно изпълнение по-горе, така и тук принтираме стойността на double usec след като я прекараме през функцията round()
        
        intCounter = 0;                         // Нулираме intCounter, за да отброим следващи 10 по 100 мили секунди изминало време(1000 милисекунди, 1 секунда) преди да обновим отново часовника. 
      }

      /* Код за изобразяване на текущата средна стойност, отчетена от антената */
      tft.fillRoundRect(230, 0, 90, 18, 5, WHITE);    // Всеки 100 милисекунди изобразяваме ново бяло поле, за да "изчистим" времето, отброено преди това.
      tft.setCursor(235, 2);
      tft.setTextColor(BLACK);
      tft.setTextSize(2);
      tft.print(average);                             // Изобразяваме новата текуща средна стойност, отчетена от антената

      /* Код за визуализиране на последните 100 отчетени средни стойности от антената */
      // Във функцията, която ще визуализираме, координатата X обозначава отминало време в период от 10 секунди, а координатата Y обозначава средна стойност отчетена от антената.
      y = average;                              // Стойността на Y се приравнява на текущата средна стойност отчетена от антената

      
      graph(tft, x, y, 50, 290, 390, 260, xTail, xHead, 1, 0, 1023, 100, "EMF_GHOST", "x = 10 seconds period", "     y = Average (1 < y < 1023)", YELLOW, CYAN, WHITE, BLACK, firstDrawGraph);

      // Код за 
      if (x >= xHead) {                         // Когато текущата стойност на X (променлива, която съхранява текущото време от 10-секундния период) достигне стойността на xHead (10)...
        xTail = 0;                              // Нулираме стойността на долната граница
        xHead = 10;                             // Връщаме горната граница към първоначалната й стойност (10)
        x = 0;                                  // Нулираме стоността на Х, така че ефективно графиката започва от координат Х = 0, което я "връща" в началото на екрана
      } else {                                  // В случай, че Х все още не е равно на 10...
        x += (0.1);      // След всяко преминаване през кода, стойността на X се увеличава с 0.1 (секунди) и времето, отнело на Arduino да изпълни кода до тук
      }

      /* Добавяне на стойности към часовника с цел обновяване през следващото преминаване през кода (цикъла) */
      intCounter += 1;                         // Отброяваме едно успешно преминаване през кода (равно на приблизително 100 милисекунди)
      usec += 0.1;                             // Увеличаваме стойността на единиците на секундите с 0.1
      // Serial.println(millis() - startTime); 
      
      delay(updateTime);                       // Караме кодът да изчака преди да премине през следващата итерация през кода от loop() цикъла. По този начин управляваме 
                                               // честотата, с която се отчитат нови данни и с която се обновява часовника. 
    }
  
  }
}

/*  Функция за визуализиране на данни под формата на графики с X и Y координати в реално време. 
 *  -----------------------------------------------------------------------------------------------
 *  Първоначална разработка от Kris Kasprzak (https://www.youtube.com/watch?v=YejRbIKe6e0 - 12.2015)
 *  Оригинални допълнения в рамките на този проект: нагледно визуализиране на данни в реално време, 
 *  показване на отминалото време от началото на визуализацията, превод и коментиране на функцията на 
 *  български език. (9.2018)
 *  
 *  Параметри 
 *  ...............................................................................................
 *  d       = Adafruit_HX8357 обект, който ще бъде управляван и променян в рамките на функцията
 *  x       = X стойност
 *  y       = Y стойност
 *  gx      = X местоположение на графиката (спрямо долу вляво)
 *  gy      = Y местоположение на графиката (спрямо долу вляво)
 *  w       = ширина на графиката
 *  h       = височина на графиката
 *  xlo     = долна граница на координатата X 
 *  xhi     = горна граница на координатата X 
 *  xinc    = разстоянието между сегментите на координатата X (не брой)
 *  ylo     = долна граница на координатата Y
 *  yhi     = горна граница на координатата Y
 *  yinc    = разстояние между сегментите на координатата Y (не брой)
 *  title   = заглавие на графиката
 *  xlabel  = заглавие на координатата Х
 *  ylabel  = заглавие на координатата Y
 *  acolor  = цвят на векторите, обозначаващи координатите Х и Y
 *  pcolor  = цвят на визуализираните данни (графиката) като line chart (графика от множество линии)
 *  tcolor  = цвят на текста
 *  bcolor  = цвят на фона
 *  &firstDrawGraph = променлива, сигнализираща дали графиката трябва да бъде изобразена за пръв 
 *                    път, включително всички периферни текстове и обозначения на координати. 
 *                    Използването на & преди подаването на параметъра във функцията ни позволява да
 *                    приемем референция към обекта, който е дефиниран глобално преди началото на 
 *                    функциите. По този начин можем да го променим, при нужда, от всяка функция, 
 *                    която има достъп до него, и при следващото повикване на тази функция, 
 *                    тя ще има достъп до неговата най-нова и текуща стойност. 
 */

void graph(Adafruit_HX8357 &d, double x, double y, double gx, double gy, double w, double h, double xlo, 
           double xhi, double xinc, double ylo, double yhi, double yinc, String title, 
           String xlabel, String ylabel, unsigned int acolor, 
           unsigned int pcolor, unsigned int tcolor, unsigned int bcolor, boolean &firstDrawGraph) {

  /* Код за еднократно изобразяване на елементи, необходими за визуализацията на данни */
  if(firstDrawGraph){

    // Изчисляване на началните стойности на X и Y
    ox = (x - xlo) * (w) / (xhi - xlo) + gx;
    oy = (y - ylo) * (gy - h - gy) / (yhi - ylo) + gy;
    
    // Преминаване през всички зададени сегменти по координатата Y
    for (double i = ylo; i <= yhi; i += yinc) {
      
      // Изобразяване на сегментите по координатата Y 
      double temp =  (i - ylo) * (gy - h - gy) / (yhi - ylo) + gy;  // Променливата temp ни помага правилно да разположим "заглавията" на сегментите според 
                                                                    // зададените параметри на графиката и разстояние между сегментите по координатата Y
      
      // Изобразяване на "заглавията" на сегментите по координатата Y (числените стойности според разстоянието между сегментите)
      d.setTextSize(1);
      d.setTextColor(tcolor, bcolor);
      d.setCursor(gx - 40, temp);                                   // Благодарение на изчисленията на променливата temp, можем да сме сигурни че текстът ще е разположен правилно
      d.print((int)i);
    }

    // Преминаваме през всички зададени сегменти по координатата X
    for (double i = xlo; i <= xhi; i += xinc) {
      double temp =  (i - xlo) * ( w) / (xhi - xlo) + gx;

      // Изобразяваме две вертикални линии, които да обозначат началото и края на графиката (от ляво надясно)
      if ((int)i == 0) {                                            // Изобразяваме началната линия на сегмент 0
        d.drawLine(temp - 5, gy, temp - 5, gy - h, acolor);         // Отместваме началната линия с 5 пиксела наляво за по-добра нагледност на изображението 
      }
      if ((int)i == 10) {                                           // Изобразяваме крайната линия на сегмент 10
        d.drawLine(temp + 5, gy, temp + 5, gy - h, acolor);         // Отместваме крайната линия с 5 пиксела надясно за по-добра нагледност на изображението
      }
      
      // Изобразяване на "заглавията" на сегментите по координатата X (числените стойности според разстоянието между сегментите)
      d.setTextSize(1);
      d.setTextColor(tcolor, bcolor);
      d.setCursor(temp, gy + 10);                                   // Благодарение на изчисленията на променливата temp, можем да сме сигурни че текстът ще е разположен правилно
      d.print((int)i);
    }

    // Изобразяване на заглавието на графиката. В нашия случай, това е временното работно име на проекта.
    d.setTextSize(2);
    d.setTextColor(tcolor, bcolor);
    d.setCursor(gx , gy - h - 30);
    d.print(title);

    // Изобразяване на описанието на координатата X за допълнителна нагледност и информиране на потребителя. 
    d.setTextSize(1);
    d.setTextColor(acolor, bcolor);
    d.setCursor(gx , gy + 20);
    d.print(xlabel);

    // Изобразяване на описанието на координатата Y за допълнителна нагледност и информиране на потребителя. 
    d.setTextSize(1);
    d.setTextColor(acolor, bcolor);
    d.setCursor(gx - 30, gy - h - 10);
    d.print(ylabel);

    firstDrawGraph = false;                                         // Тъй като вече сме изобразили всички елементи за еднократно изобразяване, посочваме стойност false 
                                                                    // за firstDrawGraph, за да спестим на програмата да минава през тази част от цикъла. По този начин 
                                                                    // доближаваме програмата допълнително към визуализиране на данните в реално време и пестим ресурси. 
  }
  
  // Изчисляване на новите стойности на координатите X и Y 
  x =  (x - xlo) * (w) / (xhi - xlo) + gx;
  y =  (y - ylo) * (gy - h - gy) / (yhi - ylo) + gy;

  // Визуализираме данните само в диапазона 50 < x < 440 за нагледност на визуализацията
  if(!((int) ox == 440 && (int) x == 50)){
    d.drawLine(ox, oy, x, y, pcolor);                               // Изобразяваме линия с начални координати ox и oy и крайни координати x и y, използвайки цветът pcolor
    d.drawLine(ox, oy + 1, x, y + 1, pcolor);                       // Изобразяаме втора линия, този път с начални и крайни координати, в които координатите на y са с 1 пиксел по-големи
    d.drawLine(ox, oy - 1, x, y - 1, pcolor);                       // Изобразяваме трета линия, този път с начални и крайни координати, в които координатите на y са с 1 пискел по-малки. 
                                                                    // Изобразяването на втората и третата линия е направено за постигане на по-дебела и по-лесно видима черта на визуализация. 
  }

  // За постигането на визуализация в реално време, изобразяваме черен правоъгълник след всяка нова точка на графиката. 
  // Използвайки кодът за "цикличност" при xHead и xTail, този правоъгълник "изтрива" старите стойности от миналия 10-секунден период, 
  // докато новите данни се връщат на x = 0 и започват да бъдат изобразявани от начало. 
  // Това се случва с минимално закъснение между x = 10 и x = 0 - само времето, необходимо за преминаването през цикъла loop() един път. 
  // Тази комбинация, заедно с визуализирането на времето от началото на измервателния период, създават ефект на визуализиране на данни в реално време. 
  if(x <= 420){
    d.fillRect(x, 29, 25, 265, BLACK);
  }

  // Подготвяме променливите за следващия цикъл, като приравняваме старите стойности за OX и OY на новите стойности X и Y. 
  ox = x;
  oy = y;
}
